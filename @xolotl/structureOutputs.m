
%               _       _   _ 
%    __  _____ | | ___ | |_| |
%    \ \/ / _ \| |/ _ \| __| |
%     >  < (_) | | (_) | |_| |
%    /_/\_\___/|_|\___/ \__|_|
%
% ### structureOutput
%
% integrates a `xolotl` model.
%
% **Syntax**
%
% ```matlab
% data = x.structureOutput(V, Ca, mech_state, I, syn_state)
% ```
%
% **Description**
%
% Converts the matrices generated by x.integrate into a structure
% so that it is easier to identify the outputs of a particular component
% This is especially useful in complex models with differently-sized
% mechanisms or synapses. 
%
% This method is used internally in x.integrate, when 
% `output_type` > 0, but can also be used
% independently 
%
%
%
% See Also: 
% xolotl.integrate


function data = structureOutputs(self,V,Ca,mech_state,curr_state,syn_state)

assert(nargin == 6,'6 arguments required, which are all outputs from x.integrate')

% first, determine sizes or all mechanisms and synapses
[~,f] = fileparts(self.linked_binary);
f = str2func(f);
arguments = self.serialize;
comp_names = self.find('compartment');
n_comp = length(comp_names);
[mech_sizes, syn_sizes] = f(arguments);


data = struct;



for i = 1:n_comp
	if isnan(sum(self.V_clamp(:,i)))
		data.(comp_names{i}).V = V(:,i);
	else
		data.(comp_names{i}).I_clamp = V(:,i);
		data.(comp_names{i}).V_clamp = self.V_clamp(:,i);
	end
end


% calcium and E_Ca
for i = 1:n_comp
	data.(comp_names{i}).Ca = Ca(:,i);
	data.(comp_names{i}).E_Ca = Ca(:,i+n_comp);
end


% all mechanisms
all_mechanisms = self.find('mechanism');
a = 1;
for i = 1:length(mech_sizes)
	this_mech_size = mech_sizes(i);

	if this_mech_size == 0
		continue
	end

	z = a + this_mech_size - 1;
	data = structlib.write(data, all_mechanisms{i}, mech_state(:,a:z));
	a = z + 1;
end


% all currents
a = 1;
for i = 1:n_comp
	cond_names = self.(comp_names{i}).find('conductance');
	for j = 1:length(cond_names)
		data.(comp_names{i}).(cond_names{j}).I = curr_state(:,a);
		a = a + 1;
	end
end


% all synapses
all_synapses = self.find('synapse');
a = 1;
for i = 1:length(syn_sizes)
	this_syn_size = syn_sizes(i);

	if this_syn_size == 0
		continue
	end

	z = a + this_syn_size - 1;
	data = structlib.write(data, [all_synapses{i},'.state'], syn_state(:,a:z));
	a = z + 1;
end

